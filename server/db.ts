import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import { neon } from '@neondatabase/serverless';
import { drizzle as drizzleNeon } from 'drizzle-orm/neon-http';
import * as schema from '../shared/schema.js';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import path from 'path';
import * as fs from 'fs';

// –ò—Å–ø–æ–ª—å–∑—É–µ–º PostgreSQL –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
console.log('Using PostgreSQL database');

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∑–∞–ø—É—â–µ–Ω–æ –ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ Render.com
const IS_RENDER = process.env.RENDER === 'true';
const IS_PRODUCTION = process.env.NODE_ENV === 'production';

// –ü–æ–ª—É—á–∞–µ–º DATABASE_URL –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
const DATABASE_URL = process.env.DATABASE_URL;

if (!DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is not set');
}

// –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ DATABASE_URL –Ω–µ undefined
const databaseUrl: string = DATABASE_URL;

console.log('Connecting to PostgreSQL database...');

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∑–∞–ø—É—â–µ–Ω–æ –ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ Vercel
const IS_VERCEL = process.env.VERCEL === '1' || process.env.NODE_ENV === 'production';

// –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏–π
let client: any;
let db: any;

if (IS_VERCEL) {
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º Neon serverless –∫–ª–∏–µ–Ω—Ç –¥–ª—è Vercel - –ù–ï–¢ –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ô –°–û–ï–î–ò–ù–ï–ù–ò–ô!
  console.log('üöÄ –ò—Å–ø–æ–ª—å–∑—É–µ–º Neon serverless –∫–ª–∏–µ–Ω—Ç –¥–ª—è Vercel');
  const sql = neon(databaseUrl);
  db = drizzleNeon(sql, { schema });
  client = sql; // –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
} else {
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π postgres –∫–ª–∏–µ–Ω—Ç –¥–ª—è Replit/–ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
  console.log('üîß –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π postgres –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏');
  client = postgres(databaseUrl, { 
    ssl: { rejectUnauthorized: false },
    max: 3, // –ë–æ–ª—å—à–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
    idle_timeout: 30,
    connect_timeout: 30,
    max_lifetime: 600,
    prepare: false,
    no_prepare: true,
    transform: {
      undefined: null
    },
    types: {
      date: {
        to: 1184,
        from: [1082, 1083, 1114, 1184],
        serialize: (date: Date) => date,
        parse: (date: string) => date
      }
    },
    onnotice: () => {},
    debug: false,
    connection: {
      application_name: 'replit-dev'
    }
  });
  db = drizzle(client, { schema });
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–ª–∏–µ–Ω—Ç—ã
export { client, db };

// –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –≤ PostgreSQL –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
async function createTablesIfNotExist() {
  try {
    console.log('Checking and creating database tables if needed...');
    
    // –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
    const executeSQL = IS_VERCEL 
      ? (sql: string) => client(sql) // Neon serverless
      : (sql: string) => client([sql] as any); // postgres.js
    
    // –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã —Å –ø—Ä—è–º—ã–º–∏ SQL –∑–∞–ø—Ä–æ—Å–∞–º–∏
    await executeSQL(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username TEXT NOT NULL UNIQUE,
        password TEXT NOT NULL,
        is_regulator BOOLEAN NOT NULL DEFAULT false,
        regulator_balance TEXT NOT NULL DEFAULT '0',
        last_nft_generation TIMESTAMP,
        nft_generation_count INTEGER NOT NULL DEFAULT 0
      )
    `);
    
    await executeSQL(`
      CREATE TABLE IF NOT EXISTS cards (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL,
        type TEXT NOT NULL,
        number TEXT NOT NULL,
        expiry TEXT NOT NULL,
        cvv TEXT NOT NULL,
        balance TEXT NOT NULL DEFAULT '0',
        btc_balance TEXT NOT NULL DEFAULT '0',
        eth_balance TEXT NOT NULL DEFAULT '0',
        kichcoin_balance TEXT NOT NULL DEFAULT '0',
        btc_address TEXT,
        eth_address TEXT,
        ton_address TEXT
      )
    `);
    
    await executeSQL(`
      CREATE TABLE IF NOT EXISTS transactions (
        id SERIAL PRIMARY KEY,
        from_card_id INTEGER NOT NULL,
        to_card_id INTEGER,
        amount TEXT NOT NULL,
        converted_amount TEXT NOT NULL,
        type TEXT NOT NULL,
        wallet TEXT,
        status TEXT NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        description TEXT NOT NULL DEFAULT '',
        from_card_number TEXT NOT NULL,
        to_card_number TEXT
      )
    `);
    
    await executeSQL(`
      CREATE TABLE IF NOT EXISTS exchange_rates (
        id SERIAL PRIMARY KEY,
        usd_to_uah TEXT NOT NULL,
        btc_to_usd TEXT NOT NULL,
        eth_to_usd TEXT NOT NULL,
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);
    
    // –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –¥–ª—è —Å–µ—Å—Å–∏–π –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
    await executeSQL(`
      CREATE TABLE IF NOT EXISTS session (
        sid TEXT PRIMARY KEY,
        sess JSON NOT NULL,
        expire TIMESTAMP(6) NOT NULL
      )
    `);

    // –°–æ–∑–¥–∞–µ–º NFT —Ç–∞–±–ª–∏—Ü—ã
    await executeSQL(`
      CREATE TABLE IF NOT EXISTS nft_collections (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id),
        name TEXT NOT NULL,
        description TEXT,
        cover_image TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);

    await executeSQL(`
      CREATE TABLE IF NOT EXISTS nfts (
        id SERIAL PRIMARY KEY,
        collection_id INTEGER NOT NULL REFERENCES nft_collections(id),
        owner_id INTEGER NOT NULL REFERENCES users(id),
        name TEXT NOT NULL,
        description TEXT,
        image_path TEXT NOT NULL,
        attributes JSONB,
        rarity TEXT NOT NULL DEFAULT 'common',
        price TEXT DEFAULT '0',
        for_sale BOOLEAN NOT NULL DEFAULT false,
        minted_at TIMESTAMP NOT NULL DEFAULT NOW(),
        token_id TEXT NOT NULL,
        original_image_path TEXT,
        sort_order INTEGER
      )
    `);

    await executeSQL(`
      CREATE TABLE IF NOT EXISTS nft_transfers (
        id SERIAL PRIMARY KEY,
        nft_id INTEGER NOT NULL REFERENCES nfts(id),
        from_user_id INTEGER NOT NULL REFERENCES users(id),
        to_user_id INTEGER NOT NULL REFERENCES users(id),
        transfer_type TEXT NOT NULL,
        price TEXT DEFAULT '0',
        transferred_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);
    
    console.log('Database tables created or verified successfully');
    return true;
  } catch (error) {
    console.error('Error creating tables:', error);
    throw error;
  }
}

// Test database connection and log content
async function logDatabaseContent() {
  try {
    console.log('Testing database connection...');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–∞–±–ª–∏—Ü –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    let usersResult: schema.User[] = [];
    try {
      usersResult = await db.select().from(schema.users);
      console.log('Successfully connected to database');
      console.log('Users count:', usersResult.length);
    } catch (e) {
      console.log('Users table not ready yet or empty');
      usersResult = [];
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Ä—Ç—ã
    try {
      const cardsResult = await db.select().from(schema.cards);
      console.log('Cards count:', cardsResult.length);
    } catch (e) {
      console.log('Cards table not ready yet or empty');
    }
    
    // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –±–∞–∑–∞ –ø—É—Å—Ç–∞
    if (usersResult && usersResult.length === 0) {
      console.log('Database is empty, creating initial data...');
      await createDefaultData();
    }
    
  } catch (error) {
    console.error('Error connecting to database:', error);
    throw error; // Propagate the error
  }
}

// –°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
async function createDefaultData() {
  try {
    // –°–æ–∑–¥–∞–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∫—É—Ä—Å—ã –æ–±–º–µ–Ω–∞
    await db.insert(schema.exchangeRates).values({
      usdToUah: "40.5",
      btcToUsd: "65000",
      ethToUsd: "3500"
    });
    console.log('Created default exchange rates');
    
    // –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ –∑–¥–µ—Å—å –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    // –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞, –Ω–æ –º—ã –æ—Å—Ç–∞–≤–∏–º —ç—Ç–æ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
    
  } catch (error) {
    console.error('Error creating default data:', error);
  }
}

// Export the initialization function
export async function initializeDatabase() {
  try {
    // –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã
    await createTablesIfNotExist();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –±–∞–∑—ã
    await logDatabaseContent();
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è KICHCOIN –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç (–¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ç–∞–±–ª–∏—Ü)
    try {
      await executeSQL(`
        ALTER TABLE cards 
        ADD COLUMN IF NOT EXISTS kichcoin_balance TEXT NOT NULL DEFAULT '0'
      `);
      
      await executeSQL(`
        ALTER TABLE cards 
        ADD COLUMN IF NOT EXISTS ton_address TEXT
      `);
      
      console.log('‚úÖ KICHCOIN –∫–æ–ª–æ–Ω–∫–∏ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö');
    } catch (error) {
      console.log('‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ KICHCOIN –∫–æ–ª–æ–Ω–æ–∫:', error);
    }

console.log('Database initialization completed successfully');
  } catch (error) {
    console.error('Database initialization failed:', error);
    throw error;
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
export async function closeConnectionsOnVercel() {
  if (!IS_VERCEL && client && typeof client.end === 'function') {
    try {
      await client.end();
      console.log('‚úÖ Database connections closed');
    } catch (e) {
      console.error('‚ùå Error closing database:', e);
    }
  }
  // –ù–∞ Vercel —Å Neon serverless —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
}

// Handle graceful shutdown
process.on('SIGTERM', async () => {
  console.log('Received SIGTERM. Closing database connection...');
  try {
    await client.end();
  } catch (e) {
    console.error('Error closing database:', e);
  }
});

process.on('SIGINT', async () => {
  console.log('Received SIGINT. Closing database connection...');
  try {
    await client.end();
  } catch (e) {
    console.error('Error closing database:', e);
  }
});

// Initialize the database connection with simpler logic
async function initializeWithRetry() {
  try {
    console.log('Initializing database tables...');
    await initializeDatabase();
    console.log('Database initialized successfully');
  } catch (error) {
    console.error('Database initialization failed:', error);
    // –ù–µ –ø–∞–Ω–∏–∫—É–µ–º, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É - —Ç–∞–±–ª–∏—Ü—ã –º–æ–≥—É—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å
  }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
initializeWithRetry();
